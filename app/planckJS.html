<!DOCTYPE html>
<html>
<head>
    <title></title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/planck-js/0.1.34/planck-with-testbed.js"></script>
</head>
<body>
    <div class="box" style="position: absolute; z-index: 10; left: 100px; top: 100px; width: 50px; height: 50px; background-color: red;">
        
    </div>
<script>
    // implement render instead testbed here
    var render = function(world){
        // render & get next frame physics world info
        var handler = null;
        window.requestAnimationFrame(handler = function() {
            // in each frame call world.step(timeStep) with fixed timeStep
            world.step(1 / 60);

            console.log(1);

            // iterate over bodies and fixtures
            // for (var body = world.getBodyList(); body; body = body.getNext()) {
            //   for (var fixture = body.getFixtureList(); fixture; fixture = fixture.getNext()) {
            //     // draw or update fixture
            //   }
            window.requestAnimationFrame(handler);
            // }
        });
    };

    var main = function(world){
        var testbed = this;

        // step01 create ground
        var groundFD = {
            density : 0.0,
            friction : 0.1
        };
        var ground = world.createBody(planck.Vec2(0.0, 0.0));
        ground.createFixture(planck.Edge(planck.Vec2(-55.0, 0.0), planck.Vec2(50.0, 10.0)), groundFD);
        // connect from lowerBound point by AABB box
        var ground = world.createBody(ground.getFixtureList().getAABB(0).lowerBound);
        ground.createFixture(planck.Edge(planck.Vec2(-20.0, 5.0), planck.Vec2(0.0, 0.0)), groundFD);

        // create Ball
        var ball = world.createDynamicBody(planck.Vec2(0.0, 10.0));
        var ballFD = {
            density: 7,
            friction: 0.1,
        };
        ball.createFixture(planck.Circle(2), ballFD);

        // sync testbed camera with ball(trigger when step invoke in testbed)
        testbed.step = function(){
            testbed.x = ball.getPosition().x;
            var angle = ball.getAngle();
            // document.querySelector('.box').style.transform = `rotate(-${angle}rad)`;
            document.querySelector('.box').style.transform = `rotate(${angle.screenAngle()}rad)`;
        };
    };
</script>
<script>
    // World Angle to Screen Angle, 360 = 2 * Math.PI;
    Number.prototype.screenAngle = function(){
        return this * -1;
    };

    // World Coordinate to Screen Coordinate.
    planck.Vec2.prototype.asScreenCoordinate = function(width, height){
        /*
        planck.Vec2(1,-7).asScreenCoordinate(800, 600)
        -> Object {x: 401, y: 307
        */
        return {
            x: this.x + width / 2,
            y: height / 2 - this.y
        };
    };

    // testbed create canvas element automatically( in testbed need not call world.step(n) )
    planck.testbed(function(testbed) {
        // testbed.width = 400;  // canvas viewport scale.
        // testbed.height = 300;  // canvas viewport scale.
        // debugger;

        var world = planck.World({
            gravity : planck.Vec2(0, -9.8)
        });

        // rest of your code
        main.call(testbed, world);

        return world; // make sure you return the world
    });
</script>
</body>
</html>